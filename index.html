<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>OmniTrack</title>
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="OmniTrack">
    <meta name="theme-color" content="#0f172a">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Dynamic Manifest & Icons -->
    <link rel="manifest" id="dynamic-manifest">
    <link rel="icon" type="image/png" id="dynamic-favicon">
    <link rel="apple-touch-icon" id="dynamic-apple-icon">

    <!-- Libraries -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        brand: { 50: '#f0f9ff', 500: '#0ea5e9', 600: '#0284c7', 900: '#0c4a6e' },
                        dark: { bg: '#0f172a', card: '#1e293b', text: '#f8fafc', border: '#334155' }
                    },
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    animation: { 'fade-in': 'fadeIn 0.3s ease-out' },
                    keyframes: { fadeIn: { '0%': { opacity: '0', transform: 'translateY(10px)' }, '100%': { opacity: '1', transform: 'translateY(0)' } } }
                }
            }
        }
    </script>

    <style>
        body { background-color: #0f172a; color: #f8fafc; -webkit-tap-highlight-color: transparent; font-family: 'Inter', sans-serif; overscroll-behavior-y: none; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .safe-top { padding-top: env(safe-area-inset-top); }
        .safe-bottom { padding-bottom: env(safe-area-inset-bottom); }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // --- PWA Initialization ---
        const usePWAInitialization = () => {
            useEffect(() => {
                const initPWA = async () => {
                    // 1. Generate Icon
                    const canvas = document.createElement('canvas');
                    canvas.width = 512; canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#0f172a'; ctx.beginPath(); ctx.roundRect(0, 0, 512, 512, 128); ctx.fill();
                    ctx.strokeStyle = '#0ea5e9'; ctx.lineWidth = 40; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(100, 400); ctx.lineTo(100, 300); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(256, 400); ctx.lineTo(256, 150); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(412, 400); ctx.lineTo(412, 250); ctx.stroke();
                    
                    const iconUrl = canvas.toDataURL('image/png');
                    document.getElementById('dynamic-favicon').href = iconUrl;
                    document.getElementById('dynamic-apple-icon').href = iconUrl;

                    // 2. Generate Manifest
                    const manifest = {
                        "name": "OmniTrack", "short_name": "OmniTrack", "start_url": window.location.href,
                        "display": "standalone", "background_color": "#0f172a", "theme_color": "#0f172a",
                        "orientation": "portrait", "icons": [{ "src": iconUrl, "sizes": "512x512", "type": "image/png" }]
                    };
                    const manifestBlob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
                    document.querySelector('#dynamic-manifest').setAttribute('href', URL.createObjectURL(manifestBlob));

                    // 3. Register Smart Service Worker (Caching + Updates)
                    if ('serviceWorker' in navigator) {
                        const swCode = `
                            const CACHE_NAME = 'omnitrack-cache-v1';
                            const WEEK_IN_MS = 7 * 24 * 60 * 60 * 1000;
                            
                            self.addEventListener('install', (event) => self.skipWaiting());
                            self.addEventListener('activate', (event) => event.waitUntil(self.clients.claim()));

                            // Helper to fetch from network and update cache + timestamp
                            async function fetchAndCache(request, cache) {
                                const networkResponse = await fetch(request);
                                if (networkResponse.status === 200) {
                                    await cache.put(request, networkResponse.clone());
                                    // Store the current timestamp as a virtual file
                                    await cache.put(new Request('/_last_update_check'), new Response(Date.now().toString()));
                                }
                                return networkResponse;
                            }

                            self.addEventListener('fetch', (event) => {
                                const url = new URL(event.request.url);
                                
                                // Strategy 1: App Shell (HTML) - Check for updates only once a week
                                if (event.request.mode === 'navigate' || (location.origin === url.origin && url.pathname.endsWith('.html'))) {
                                     event.respondWith((async () => {
                                        const cache = await caches.open(CACHE_NAME);
                                        const cachedResponse = await cache.match(event.request);
                                        
                                        // Case A: First time load (No cache) -> Must go network
                                        if (!cachedResponse) {
                                            try { return await fetchAndCache(event.request, cache); }
                                            catch (e) { return new Response('Offline: Connect to internet first.', { status: 503 }); }
                                        }

                                        // Case B: Check if our 7-day timer has expired
                                        const lastCheckRes = await cache.match(new Request('/_last_update_check'));
                                        let isExpired = true;
                                        
                                        if (lastCheckRes) {
                                            const lastTime = await lastCheckRes.text();
                                            if (Date.now() - parseInt(lastTime) < WEEK_IN_MS) {
                                                isExpired = false;
                                            }
                                        }

                                        // Case C: If expired, try network. If valid or offline, use cache.
                                        if (isExpired) {
                                            try {
                                                return await fetchAndCache(event.request, cache);
                                            } catch (e) {
                                                console.log('Update check failed (offline), using cache.');
                                                return cachedResponse; // Fallback to cache if offline
                                            }
                                        } else {
                                            return cachedResponse;
                                        }
                                     })());
                                     return;
                                }

                                // Strategy 2: Cache First (for Libraries/CDNs)
                                // This saves React, Chart.js, etc. locally so you don't need internet.
                                if (['unpkg.com', 'cdn.jsdelivr.net', 'cdn.tailwindcss.com'].some(domain => url.hostname.includes(domain))) {
                                    event.respondWith(
                                        caches.match(event.request).then((cachedResponse) => {
                                            if (cachedResponse) return cachedResponse;
                                            return fetch(event.request).then((networkResponse) => {
                                                return caches.open(CACHE_NAME).then((cache) => {
                                                    cache.put(event.request, networkResponse.clone());
                                                    return networkResponse;
                                                });
                                            });
                                        })
                                    );
                                } else {
                                    event.respondWith(fetch(event.request));
                                }
                            });
                        `;
                        const swBlob = new Blob([swCode], {type: 'application/javascript'});
                        try { await navigator.serviceWorker.register(URL.createObjectURL(swBlob)); } catch (e) {}
                    }
                };
                initPWA();
            }, []);
        };

        const generateId = () => Math.random().toString(36).substr(2, 9);
        const Icon = ({ name, size = 20, className = "" }) => {
            useEffect(() => { if (window.lucide) window.lucide.createIcons(); }, [name]);
            return <i data-lucide={name} width={size} height={size} className={className}></i>;
        };

        // --- COMPONENTS ---

        const InputModal = ({ item, isOpen, onClose, onConfirm }) => {
            const [val, setVal] = useState('');
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-fade-in">
                    <form onSubmit={(e) => { 
                        e.preventDefault(); 
                        const num = parseFloat(val);
                        if (!isNaN(num)) {
                            onConfirm(item.id, num); 
                            setVal(''); 
                            onClose(); 
                        }
                    }} 
                        className="bg-dark-card w-full max-w-sm rounded-2xl p-6 border border-dark-border shadow-2xl">
                        <div className="flex justify-between items-center mb-6">
                            <h3 className="text-xl font-bold text-slate-100">Add {item.name}</h3>
                            <button type="button" onClick={onClose} className="text-slate-400"><Icon name="x" /></button>
                        </div>
                        <input autoFocus type="number" step="any" value={val} onChange={(e) => setVal(e.target.value)}
                            className="w-full bg-slate-900 text-white text-4xl font-bold p-6 rounded-2xl text-center border-2 border-slate-700 focus:border-brand-500 outline-none mb-6" placeholder="0" />
                        <button type="submit" className="w-full py-4 rounded-xl font-bold bg-brand-600 text-white shadow-lg text-lg">Confirm</button>
                    </form>
                </div>
            );
        };

        const TrackerCard = ({ item, logs, onAdd }) => {
            const [showInput, setShowInput] = useState(false);
            const todayTotal = useMemo(() => {
                const start = new Date(); start.setHours(0,0,0,0);
                return logs.filter(l => l.itemId === item.id && new Date(l.timestamp) >= start)
                           .reduce((acc, curr) => acc + curr.value, 0);
            }, [logs, item.id]);

            return (
                <div className="bg-dark-card rounded-2xl p-5 border border-dark-border shadow-lg relative overflow-hidden group">
                    <div className="absolute top-0 left-0 w-1.5 h-full" style={{ backgroundColor: item.color }}></div>
                    <div className="flex justify-between items-start mb-4 pl-3">
                        <div><h3 className="text-lg font-bold text-slate-100">{item.name}</h3><p className="text-xs text-slate-400 uppercase font-bold tracking-wider">{item.unit}</p></div>
                        <div className="text-right">
                            <span className="block text-3xl font-black text-white tracking-tight">{Number.isInteger(todayTotal)?todayTotal:todayTotal.toFixed(1)}</span>
                            <span className="text-xs text-brand-500 font-bold bg-brand-500/10 px-2 py-0.5 rounded">TODAY</span>
                        </div>
                    </div>
                    <div className="grid grid-cols-4 gap-3 pl-3">
                        <button onClick={() => onAdd(item.id, item.step)} className="col-span-3 bg-slate-800 active:scale-[0.98] transition-all py-3.5 rounded-xl flex items-center justify-center gap-2 font-bold text-slate-200 border border-slate-700 hover:border-brand-500/50"><Icon name="plus" size={18} /> Quick Add {item.step}</button>
                        <button onClick={() => setShowInput(true)} className="col-span-1 bg-slate-800 active:scale-[0.98] transition-all py-3.5 rounded-xl flex items-center justify-center text-slate-400 border border-slate-700"><Icon name="edit-3" size={18} /></button>
                    </div>
                    <InputModal item={item} isOpen={showInput} onClose={() => setShowInput(false)} onConfirm={onAdd} />
                </div>
            );
        };

        const Heatmap = ({ logs, color }) => {
            // Generate last 15 weeks of data
            const grid = useMemo(() => {
                const weeks = [];
                const today = new Date();
                const dataMap = {};
                
                logs.forEach(l => {
                    const key = new Date(l.timestamp).toDateString();
                    dataMap[key] = (dataMap[key] || 0) + l.value;
                });
                
                const maxVal = Math.max(...Object.values(dataMap), 1);

                for (let w = 14; w >= 0; w--) {
                    const week = [];
                    for (let d = 0; d < 7; d++) {
                        const date = new Date(today);
                        date.setDate(today.getDate() - (w * 7) + d - today.getDay()); // Align to Sun-Sat
                        const key = date.toDateString();
                        const val = dataMap[key] || 0;
                        const opacity = val > 0 ? Math.max(0.3, val / maxVal) : 0.1;
                        const isToday = key === today.toDateString();
                        week.push({ date, val, opacity, isToday });
                    }
                    weeks.push(week);
                }
                return weeks;
            }, [logs]);

            return (
                <div className="overflow-x-auto no-scrollbar pb-2 -mx-4 px-4">
                    <div className="flex gap-1 min-w-max">
                        {grid.map((week, i) => (
                            <div key={i} className="flex flex-col gap-1">
                                {week.map((day, j) => (
                                    <div key={j} 
                                        className={`w-3 h-3 rounded-sm transition-all ${day.isToday ? 'ring-1 ring-white' : ''}`}
                                        style={{ backgroundColor: day.val > 0 ? color : '#334155', opacity: day.val > 0 ? day.opacity : 0.3 }}
                                        title={`${day.date.toLocaleDateString()}: ${day.val}`}
                                    ></div>
                                ))}
                            </div>
                        ))}
                    </div>
                    <div className="text-[10px] text-slate-500 mt-1 text-right">Last 15 Weeks</div>
                </div>
            );
        };

        const StatCard = ({ label, value, subValue, isGood = true }) => (
            <div className="bg-slate-800/40 p-4 rounded-xl border border-dark-border">
                <div className="text-xs text-slate-400 uppercase font-bold tracking-wider mb-1">{label}</div>
                <div className="text-2xl font-black text-white">{value}</div>
                {subValue && (
                    <div className={`text-xs mt-1 font-bold flex items-center gap-1 ${isGood ? 'text-emerald-400' : 'text-rose-400'}`}>
                        {subValue}
                    </div>
                )}
            </div>
        );

        const ChartView = ({ data, labels, color, type = 'bar' }) => {
            const canvasRef = useRef(null);
            const chartRef = useRef(null);
            
            useEffect(() => {
                if (!canvasRef.current) return;
                if (chartRef.current) chartRef.current.destroy();

                const isLine = type === 'line';
                
                chartRef.current = new Chart(canvasRef.current.getContext('2d'), {
                    type: isLine ? 'line' : 'bar',
                    data: { 
                        labels, 
                        datasets: [{ 
                            data, 
                            backgroundColor: isLine ? color + '20' : color, 
                            borderColor: color,
                            borderWidth: isLine ? 2 : 0,
                            borderRadius: isLine ? 0 : 4, 
                            barThickness: 'flex', 
                            maxBarThickness: 32,
                            fill: isLine,
                            tension: 0.4,
                            pointRadius: isLine ? 2 : 0
                        }] 
                    },
                    options: { 
                        responsive: true, 
                        maintainAspectRatio: false, 
                        plugins: { legend: { display: false }, tooltip: { mode: 'index', intersect: false } }, 
                        scales: { 
                            y: { 
                                beginAtZero: true, 
                                grid: { color: '#334155', drawBorder: false }, 
                                ticks: { color: '#64748b', font: {size: 10} } 
                            }, 
                            x: { 
                                grid: { display: false }, 
                                ticks: { color: '#64748b', font: {size: 10}, maxRotation: 0, autoSkip: true, maxTicksLimit: 6 } 
                            } 
                        },
                        interaction: { mode: 'nearest', axis: 'x', intersect: false }
                    }
                });
                return () => chartRef.current?.destroy();
            }, [data, labels, color, type]);
            
            return <div className="h-48 w-full"><canvas ref={canvasRef}></canvas></div>;
        };

        const HourlyChart = ({ logs, color }) => {
             const canvasRef = useRef(null);
             const chartRef = useRef(null);
             
             const data = useMemo(() => {
                 const hours = Array(24).fill(0);
                 logs.forEach(l => {
                     const h = new Date(l.timestamp).getHours();
                     hours[h] += l.value;
                 });
                 return hours;
             }, [logs]);

             useEffect(() => {
                if (!canvasRef.current) return;
                if (chartRef.current) chartRef.current.destroy();
                chartRef.current = new Chart(canvasRef.current.getContext('2d'), {
                    type: 'line',
                    data: { 
                        labels: Array.from({length:24}, (_,i) => i), 
                        datasets: [{ 
                            data, 
                            borderColor: color, 
                            backgroundColor: color + '20', 
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0
                        }] 
                    },
                    options: { 
                        responsive: true, 
                        maintainAspectRatio: false, 
                        plugins: { legend: { display: false } }, 
                        scales: { y: { display: false }, x: { display: false } } 
                    }
                });
                return () => chartRef.current?.destroy();
            }, [data, color]);
            return <div className="h-16 w-full"><canvas ref={canvasRef}></canvas></div>;
        };

        // --- VIEWS ---

        const Dashboard = ({ items, logs }) => {
            const [selectedId, setSelectedId] = useState(items[0]?.id);
            const [period, setPeriod] = useState('7d');
            const [chartType, setChartType] = useState('bar'); // bar, line
            
            const selectedItem = items.find(i => i.id === selectedId);

            const stats = useMemo(() => {
                if (!selectedItem) return null;
                const now = new Date();
                
                // 1. Logic for Start Date & Grouping
                let startDate = new Date();
                let prevStartDate = new Date();
                let grouping = 'day'; // day, week, month
                let daysCount = 7;

                switch(period) {
                    case '7d':
                        startDate.setDate(now.getDate() - 7);
                        prevStartDate.setDate(now.getDate() - 14);
                        daysCount = 7;
                        grouping = 'day';
                        break;
                    case '30d':
                        startDate.setDate(now.getDate() - 30);
                        prevStartDate.setDate(now.getDate() - 60);
                        daysCount = 30;
                        grouping = 'day';
                        break;
                    case '3m':
                        startDate.setDate(now.getDate() - 90);
                        prevStartDate.setDate(now.getDate() - 180);
                        daysCount = 90;
                        grouping = 'week';
                        break;
                    case 'ytd':
                        startDate = new Date(now.getFullYear(), 0, 1);
                        prevStartDate = new Date(now.getFullYear() - 1, 0, 1); // rough comparison
                        daysCount = Math.floor((now - startDate) / (1000 * 60 * 60 * 24)) + 1;
                        grouping = daysCount > 60 ? 'week' : 'day';
                        if (daysCount > 180) grouping = 'month';
                        break;
                    case '1y':
                        startDate.setFullYear(now.getFullYear() - 1);
                        prevStartDate.setFullYear(now.getFullYear() - 2);
                        daysCount = 365;
                        grouping = 'month';
                        break;
                }
                
                // Align start dates to beginning of day
                startDate.setHours(0,0,0,0);
                prevStartDate.setHours(0,0,0,0);
                
                const currentLogs = logs.filter(l => l.itemId === selectedId && new Date(l.timestamp) >= startDate);
                const prevLogs = logs.filter(l => l.itemId === selectedId && new Date(l.timestamp) >= prevStartDate && new Date(l.timestamp) < startDate);

                const currTotal = currentLogs.reduce((a,b) => a+b.value, 0);
                const prevTotal = prevLogs.reduce((a,b) => a+b.value, 0);
                const delta = prevTotal === 0 ? (currTotal > 0 ? 100 : 0) : ((currTotal - prevTotal) / prevTotal) * 100;
                const deltaStr = (delta > 0 ? '+' : '') + delta.toFixed(0) + '%';

                // 2. Streaks & Inception Logic
                const allItemLogs = logs.filter(l => l.itemId === selectedId);
                const dates = [...new Set(allItemLogs.map(l => new Date(l.timestamp).toDateString()))].map(d => new Date(d).getTime()).sort((a,b) => b-a);
                let currentStreak = 0;
                const todayTime = new Date().setHours(0,0,0,0);
                
                if (dates.length > 0 && (dates[0] === todayTime || dates[0] === todayTime - 86400000)) {
                    currentStreak = 1;
                    let checkDate = dates[0];
                    for(let i=1; i<dates.length; i++) {
                        if (dates[i] === checkDate - 86400000) { currentStreak++; checkDate = dates[i]; } else break;
                    }
                }

                // Calculate days since this specific item started being tracked
                const firstLogTimestamp = allItemLogs.length > 0 ? Math.min(...allItemLogs.map(l => new Date(l.timestamp).getTime())) : Date.now();
                const daysSinceInception = Math.max(1, Math.ceil((new Date().getTime() - firstLogTimestamp) / (1000 * 60 * 60 * 24)));
                
                // Use the smaller of: Selected Period OR Actual Days Since Start
                // This prevents "Daily Avg" from being diluted by empty days before the item existed
                const effectiveDaysCount = Math.min(daysCount, daysSinceInception);

                // 3. Chart Bucketing
                const bucketMap = new Map();
                
                // Pre-fill buckets
                let cursor = new Date(startDate);
                while(cursor <= now) {
                    let key;
                    if (grouping === 'day') key = cursor.toDateString();
                    else if (grouping === 'week') {
                        // Start of week (Sunday)
                        const day = cursor.getDay();
                        const diff = cursor.getDate() - day;
                        const w = new Date(cursor); w.setDate(diff); w.setHours(0,0,0,0);
                        key = w.toDateString();
                    }
                    else if (grouping === 'month') key = `${cursor.getFullYear()}-${cursor.getMonth()}`;
                    
                    if (!bucketMap.has(key)) bucketMap.set(key, 0);
                    cursor.setDate(cursor.getDate() + 1);
                }

                currentLogs.forEach(l => {
                    const d = new Date(l.timestamp);
                    let key;
                    if (grouping === 'day') key = d.toDateString();
                    else if (grouping === 'week') {
                         const day = d.getDay();
                         const diff = d.getDate() - day;
                         const w = new Date(d); w.setDate(diff); w.setHours(0,0,0,0);
                         key = w.toDateString();
                    }
                    else if (grouping === 'month') key = `${d.getFullYear()}-${d.getMonth()}`;
                    
                    if (bucketMap.has(key)) bucketMap.set(key, bucketMap.get(key) + l.value);
                });

                const labels = Array.from(bucketMap.keys()).map(k => {
                    if (grouping === 'month') { const [y, m] = k.split('-'); return new Date(y, m).toLocaleDateString('en-US', { month: 'short' }); }
                    return new Date(k).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                });
                
                const values = Array.from(bucketMap.values());
                
                // Handle Cumulative
                const chartData = chartType === 'line' 
                    ? values.reduce((acc, curr, i) => [...acc, curr + (acc[i-1] || 0)], []) 
                    : values;

                return {
                    currTotal,
                    deltaStr: `${deltaStr} vs prev`,
                    isPositive: delta >= 0,
                    currentStreak,
                    avg: (currTotal / effectiveDaysCount).toFixed(1),
                    chartLabels: labels,
                    chartData,
                    allLogs: allItemLogs
                };

            }, [selectedId, period, logs, chartType]);

            if (!selectedItem) return <div className="p-8 text-center text-slate-500">No data found.</div>;

            return (
                <div className="space-y-6 pb-24 animate-fade-in">
                    {/* Item Scroller */}
                    <div className="flex overflow-x-auto no-scrollbar gap-2 -mx-4 px-4">
                        {items.map(item => (
                            <button key={item.id} onClick={() => setSelectedId(item.id)}
                                className={`whitespace-nowrap px-4 py-2 rounded-full text-sm font-bold transition-colors ${selectedId === item.id ? 'bg-brand-600 text-white shadow-lg shadow-brand-900/50' : 'bg-slate-800 text-slate-400 border border-dark-border'}`}>
                                {item.name}
                            </button>
                        ))}
                    </div>

                    {/* Stat Cards */}
                    <div className="grid grid-cols-2 gap-3">
                        <StatCard label={period === 'ytd' || period === '1y' ? "Total Volume" : "Period Total"} value={stats.currTotal} subValue={stats.deltaStr} isGood={stats.isPositive} />
                        <StatCard label="Streak" value={`${stats.currentStreak} Days`} subValue="Keep it up!" isGood={true} />
                        <StatCard label="Daily Avg" value={stats.avg} />
                        <StatCard label="Entries" value={stats.allLogs.length} />
                    </div>

                    {/* Main Chart */}
                    <div className="bg-dark-card border border-dark-border rounded-2xl p-4 shadow-lg">
                        <div className="flex justify-between items-start mb-4">
                            <div>
                                <h4 className="text-sm font-bold text-slate-300 flex items-center gap-2 mb-2"><Icon name={chartType === 'line' ? 'trending-up' : 'bar-chart-2'} size={16}/> {chartType === 'line' ? 'Cumulative Growth' : 'Volume over Time'}</h4>
                                <div className="flex bg-slate-800 rounded-lg p-0.5 overflow-x-auto max-w-[200px] no-scrollbar">
                                    {['7d', '30d', '3m', 'ytd', '1y'].map(p => (
                                        <button key={p} onClick={() => setPeriod(p)} className={`px-2.5 py-1 text-[10px] font-bold uppercase rounded-md whitespace-nowrap ${period === p ? 'bg-brand-600 text-white' : 'text-slate-500'}`}>{p}</button>
                                    ))}
                                </div>
                            </div>
                            <button onClick={() => setChartType(prev => prev === 'bar' ? 'line' : 'bar')} className="p-2 bg-slate-800 rounded-lg text-slate-400 border border-slate-700 hover:text-white">
                                <Icon name={chartType === 'bar' ? 'trending-up' : 'bar-chart-2'} size={18} />
                            </button>
                        </div>
                        <ChartView labels={stats.chartLabels} data={stats.chartData} color={selectedItem.color} type={chartType} />
                    </div>

                    {/* Heatmap */}
                    <div className="bg-dark-card border border-dark-border rounded-2xl p-4 shadow-lg">
                        <h4 className="text-sm font-bold text-slate-300 mb-3 flex items-center gap-2"><Icon name="grid" size={16}/> Consistency Map</h4>
                        <Heatmap logs={stats.allLogs} color={selectedItem.color} />
                    </div>

                    {/* Hourly Distribution */}
                    <div className="bg-dark-card border border-dark-border rounded-2xl p-4 shadow-lg overflow-hidden">
                        <h4 className="text-sm font-bold text-slate-300 mb-2 flex items-center gap-2"><Icon name="clock" size={16}/> Activity by Hour</h4>
                        <HourlyChart logs={stats.allLogs} color={selectedItem.color} />
                        <div className="flex justify-between text-[10px] text-slate-500 mt-1 px-1">
                            <span>12 AM</span><span>12 PM</span><span>11 PM</span>
                        </div>
                    </div>
                </div>
            );
        };

        const Settings = ({ items, setItems, logs, setLogs, installPrompt, isStandalone }) => {
            const [name, setName] = useState(''); const [unit, setUnit] = useState(''); const [step, setStep] = useState('');
            const addItem = (e) => {
                e.preventDefault();
                setItems([...items, { id: generateId(), name, unit, step: parseFloat(step) || 1, color: ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6'][items.length % 5] }]);
                setName(''); setUnit(''); setStep('');
            };
            return (
                <div className="space-y-6 pb-24 animate-fade-in">
                    {!isStandalone && (
                         <section className="bg-gradient-to-r from-brand-900 to-slate-900 border border-brand-500/30 p-5 rounded-2xl shadow-lg relative overflow-hidden">
                            <div className="absolute top-0 right-0 p-4 opacity-10"><Icon name="download-cloud" size={80} /></div>
                            <h3 className="text-lg font-bold text-white mb-2 relative z-10">Install OmniTrack</h3>
                            <button onClick={() => installPrompt ? installPrompt.prompt() : alert("Use browser menu to install.")} className="bg-brand-600 text-white font-bold py-2 px-6 rounded-lg relative z-10 shadow-lg">Install App</button>
                        </section>
                     )}
                    <section className="bg-dark-card border border-dark-border p-5 rounded-2xl shadow-lg">
                        <h3 className="text-lg font-bold text-white mb-4">New Metric</h3>
                        <form onSubmit={addItem} className="space-y-4">
                            <input className="w-full bg-slate-900 border border-slate-700 rounded-xl p-3 text-white outline-none focus:border-brand-500" placeholder="Name (e.g. Water)" value={name} onChange={e => setName(e.target.value)} required />
                            <div className="grid grid-cols-2 gap-4">
                                <input className="w-full bg-slate-900 border border-slate-700 rounded-xl p-3 text-white outline-none focus:border-brand-500" placeholder="Unit" value={unit} onChange={e => setUnit(e.target.value)} required />
                                <input type="number" className="w-full bg-slate-900 border border-slate-700 rounded-xl p-3 text-white outline-none focus:border-brand-500" placeholder="Step" value={step} onChange={e => setStep(e.target.value)} />
                            </div>
                            <button className="w-full bg-brand-600 py-3 rounded-xl font-bold text-white shadow-lg">Create</button>
                        </form>
                    </section>
                    <div className="space-y-2">
                        {items.map(item => (
                            <div key={item.id} className="flex justify-between bg-slate-800/50 border border-dark-border p-4 rounded-xl items-center">
                                <div className="flex items-center gap-3"><div className="w-3 h-3 rounded-full" style={{backgroundColor: item.color}}></div><span className="font-bold text-slate-200">{item.name}</span></div>
                                <button onClick={() => {if(confirm('Delete?')) { setItems(items.filter(i=>i.id!==item.id)); setLogs(logs.filter(l=>l.itemId!==item.id)); }}} className="text-red-400 p-2"><Icon name="trash-2" size={18} /></button>
                            </div>
                        ))}
                    </div>
                    <button onClick={() => {
                        const blob = new Blob([JSON.stringify({items, logs})], {type: 'application/json'});
                        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'omnitrack_backup.json'; a.click();
                    }} className="w-full bg-slate-800 text-slate-300 font-bold py-4 rounded-xl border border-dark-border flex items-center justify-center gap-2"><Icon name="download" /> Export Data</button>

                    <section className="bg-dark-card border border-dark-border p-5 rounded-2xl shadow-lg mt-4">
                        <h3 className="text-lg font-bold text-white mb-2">Feedback & Support</h3>
                        <p className="text-slate-400 text-sm mb-4">Found a bug or have a feature request?</p>
                        <a href="https://github.com/gurkanctn/OmniTracker-Pro/issues" target="_blank" className="flex items-center justify-center gap-2 w-full bg-slate-800 hover:bg-slate-700 text-white font-bold py-3 rounded-xl border border-dark-border transition">
                            <Icon name="github" size={20} /> Open GitHub Issues
                        </a>
                    </section>
                </div>
            );
        };

        const App = () => {
            usePWAInitialization();
            const [view, setView] = useState('track');
            const [items, setItems] = useState([]);
            const [logs, setLogs] = useState([]);
            const [installPrompt, setInstallPrompt] = useState(null);
            const [isStandalone, setIsStandalone] = useState(false);

            useEffect(() => {
                const handler = (e) => { e.preventDefault(); setInstallPrompt(e); };
                window.addEventListener('beforeinstallprompt', handler);
                setIsStandalone(window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true);
                const savedItems = localStorage.getItem('omni_items');
                const savedLogs = localStorage.getItem('omni_logs');
                if (savedItems) setItems(JSON.parse(savedItems));
                if (savedLogs) setLogs(JSON.parse(savedLogs));
            }, []);

            useEffect(() => {
                localStorage.setItem('omni_items', JSON.stringify(items));
                localStorage.setItem('omni_logs', JSON.stringify(logs));
            }, [items, logs]);

            const addLog = (itemId, value) => {
                setLogs(prev => [...prev, { id: generateId(), itemId, value, timestamp: new Date().toISOString() }]);
                if (navigator.vibrate) navigator.vibrate(50);
            };

            return (
                <div className="max-w-md mx-auto min-h-screen relative flex flex-col bg-dark-bg safe-top">
                    <header className="px-6 py-6 flex justify-between sticky top-0 bg-dark-bg/95 backdrop-blur-md z-40 border-b border-dark-border">
                        <div className="flex items-center gap-2 text-brand-500"><Icon name="activity" /><h1 className="text-2xl font-black text-white tracking-tight">OmniTrack</h1></div>
                    </header>
                    <main className="flex-1 px-4 pt-6 overflow-y-auto scroll-smooth safe-bottom">
                        {view === 'track' && <div className="space-y-4 pb-24 animate-fade-in">
                            {items.length === 0 ? <div className="text-center py-20 px-6 text-slate-400"><p className="mb-4">No metrics yet.</p><button onClick={()=>setView('settings')} className="bg-brand-600 text-white px-6 py-3 rounded-xl font-bold">Create One</button></div> : items.map(i => <TrackerCard key={i.id} item={i} logs={logs} onAdd={addLog} />)}
                        </div>}
                        {view === 'dashboard' && <Dashboard items={items} logs={logs} />}
                        {view === 'settings' && <Settings items={items} setItems={setItems} logs={logs} setLogs={setLogs} installPrompt={installPrompt} isStandalone={isStandalone} />}
                    </main>
                    <nav className="fixed bottom-0 w-full max-w-md bg-dark-card border-t border-dark-border pb-[env(safe-area-inset-bottom)] z-50">
                        <div className="flex justify-around items-center h-16">
                            {['track', 'dashboard', 'settings'].map(v => (
                                <button key={v} onClick={() => setView(v)} className={`flex flex-col items-center w-full transition-colors ${view === v ? 'text-brand-500' : 'text-slate-500'}`}>
                                    <Icon name={v === 'track' ? 'check-square' : v === 'dashboard' ? 'bar-chart-2' : 'settings'} size={24} />
                                    <span className="text-[10px] font-bold uppercase mt-1">{v}</span>
                                </button>
                            ))}
                        </div>
                    </nav>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
